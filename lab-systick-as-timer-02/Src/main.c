/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif


#include <FourDigitsLedDisplay2.h>


#define PIN_DATA 			2		//SDO
#define PIN_SHIFT_CLOCK 	1		//SCLK
#define PIN_STORAGE_CLOCK 	0		//LOAD

// Required for FourDigitsLedDisplay
static GPIOToLedRegisterDefinition_t  *g_ledOutput;


void enable_processor_faults(void);
void init_rtc(void);
void init_systick(void);
void init_pendSV(void);
void init_GPIO(void);
void init_GPIO_FourDigitsLed(void);
void delay(uint32_t);



uint32_t g_tick = 0;

int main(void)
{
	enable_processor_faults();
	init_systick();
	init_rtc();
	init_GPIO();
	init_GPIO_FourDigitsLed();
	init_pendSV();
    /* Loop forever */

	for(;;);
}



void enable_processor_faults(void)
{
	uint32_t *pSHCSR = (uint32_t*)0xE000ED24;

	*pSHCSR |= ( 1 << 16); //mem manage
	*pSHCSR |= ( 1 << 17); //bus fault
	*pSHCSR |= ( 1 << 18); //usage fault
}

void init_systick(void)
{
	//Program reload value. SYST_RVR Reload Value Register. Value to load into the SYST_CVR register when the counter is enabled and when it reaches 0
	//0xE000E014 SYST_RVR
	uint32_t *pSystRVR = (uint32_t*)0xE000E014;
	// Internal RC = 16 MHz
	// 1mz = 1 KHz =Timer count MHz / Reload value = 16 MHz / Reload value. Reload value = 16 MHz/1 KHz = 16 000 = 0x3E80
	*pSystRVR = 0x00FFFFFFU & (16000U-1U); // add safety mask for 8 upper bits (24 bit register)

	//Clear current value. SYST_CVR
	//0xE000E018 SYST_CVR
	// reset SYST_CVR : A write of any value clears the field to 0, and also clears the SYST_CSR COUNTFLAG bit to 0.
	uint32_t *pSystCVR = (uint32_t*)0xE000E018;
	*pSystCVR = 0x0U ; // set to 0 / reset

	//Program Control and Status register.
	//0xE000E010 SYST_CSR
	// SYST_CSR ENABLE[0]=1/Enable;
	//TICKINT[1]=Enables SysTick exception request=1/counting down to zero asserts the SysTick exception request.;
	//CLKSOURCE[2]=1 = processor clock
	// reset - see above - reset while writing to SYST_CVR
	uint32_t *pSystCSR = (uint32_t*)0xE000E010;
	*pSystCSR |= (0x1U<<2); // CLKSOURCE [2]=1 Processor clock \ internal
	*pSystCSR |= (0x1U<<1); // TICKINT [1]= 1 counting down to zero asserts the SysTick exception request.
	*pSystCSR |= (0x1U<<0); // ENABLE [0]=1 Enable


	// SysTick Handler priority
	//SHPR3 System handler priority register 3  Address: 0xE000 ED20
	uint32_t *pSHPR3 = (uint32_t *)0xE000ED20;
	//PRI_15: Priority of system handler 15, SysTick exception
	*pSHPR3 &= ~(0xFF << 24); 		// clear
	*pSHPR3 |=  (0x10 << 24); 		// set priority 1 - lowest ? 0xF0 or 0xFF ?

}
void init_rtc(void)
{

}



void init_GPIO(void)
{
	// CLOCK
	// AHB1 = RCC_AHB1ENR, GPIOA EN = bit 1
	// RCC = 0x40020000UL + 0x3800UL; RCC_AHB1ENR (RCC AHB1 peripheral clock enable register) = RCC + 0x30
	volatile uint32_t *pRCCAhb1Enr = 	(uint32_t *)(0x40020000UL + 0x3800UL + 0x30UL);
	// RCC_AHB1ENR Enable GPIOA (bit 1)
	*pRCCAhb1Enr|=(1<<0);

	// GPIO = GPIOA = 0x40020000UL
	// mode = output,  Output type = 0 Output push-pull, speed = 00: Low speed
	// GPIOA_MODER = 0x40020000UL + 0x00.  Val=01: General purpose output mode . Pin 0 = Bit [0,1] , Pin 1 = Bit [2,3] , Pin 3 = Bit [4,5]
	volatile uint32_t * pGPIOAModer = (uint32_t *)(0x40020000UL + 0x00UL);
	*pGPIOAModer &=  ~(0b111111); //clear first 6 for 0,1,2 pins    0b000000
	*pGPIOAModer |=   (0b010101); //set 01 (output) for first 6 for 0,1,2 pins
	// GPIOA_OTYPER = 0x40020000UL + 0x04.. Val = 0: Output push-pull (reset state). Pin0=0,1=1,2=2;
	volatile uint32_t * pGPIOAOType = (uint32_t *)(0x40020000UL + 0x04UL);
	*pGPIOAOType &= ~(0b111); //clear
	*pGPIOAOType |=  (0b000); //set 0 (output) for pins 0,1,2 (bit 0,1,2)
	// GPIOx_PUPDR = 0x40020000UL + 0x0C.  PUPDR2[1:0] PUPDR1[1:0] PUPDR0[1:0]/ 01: Pull-up 10: Pull-down
	volatile uint32_t *pGPIOAPuPd = (uint32_t *)(0x40020000UL + 0x0CUL);
	*pGPIOAPuPd &= ~(0b111111); //clear
	*pGPIOAPuPd |= ~(0b010101); //set 01: Pull-up

}


void init_GPIO_FourDigitsLed (void)
{
	// GPIOA_ODR = 0x40020000UL + 0x14UL. Pin0=0,1=1,2=2;
	// GPIOA_BSRR = 0x40020000UL + 0x18UL; SET Pin0=0,1=1,2=2; RESET Pin0=bit16,1=17,2=18;

	// GPIOA_ODR = 0x40020000UL + 0x14UL. Pin0=0,1=1,2=2;
	//volatile uint32_t *pGPIOAOdr = (uint32_t *)(0x40020000UL + 0x14UL);

	// GPIOA_BSRR = 0x40020000UL + 0x18UL; SET Pin0=0,1=1,2=2; RESET Pin0=bit16,1=17,2=18;
	//volatile uint32_t *pGPIOABSRR = (uint32_t *)(0x40020000UL + 0x18UL);
	g_ledOutput = gpiotoled2_init();
	g_ledOutput->pGPIOABSRR = (uint32_t *)(0x40020000UL + 0x18UL); //pGPIOABSRR;
	g_ledOutput->output_pin_data = PIN_DATA;
	g_ledOutput->output_pin_shift_clock = PIN_SHIFT_CLOCK;
	g_ledOutput->output_pin_storage_clock = PIN_STORAGE_CLOCK;
}

void init_pendSV(void)
{
	// Set priority
	//SHPR3 bit Bits 23:16 PRI_14: Priority of system handler 14, PendSV Bits 15:0 Reserved, must be kept cleared
	uint32_t *pSHPR3 = (uint32_t *)0xE000ED20;
	*pSHPR3 &= ~(0xFF << 16); 	// clear
	//*pSHPR3 |= (15 << 16); 		// set priority 15 - lowest
	*pSHPR3 |= (0xF0 << 16); 		// set priority 15 - lowest ? 0xF0 or 0xFF ?

	// AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA  DONT DO THIS
	//usage fault "Attempt to do exception with bad value in EXEC_RETURN number (INVPC)" while calling PendSV
	// IDIOT - this is the ACTIVE(!) bit, not ENABLE (!)
	//Enable PendSV
	//SHCSR Address offset: 0x24 0xE000ED24 Bit 10 PENDSVACT: PendSV exception active bit, reads as 1 if exception is active
	//uint32_t *pSHCSR = (uint32_t *)0xE000ED24;
	//*pSHCSR |= (1<<10); 		// Enable PendSV

}


void delay(uint32_t time)
{
	for (uint32_t i =0 ; i< time; i++);

}



/**********************************************************************/
void SysTick_Handler(void)
{
	g_tick++;
	gpiotoled2_set_millis(g_tick);

	//SCB. Interrupt control and state register (ICSR)
	//Address offset: 0x04
	//Bit 28 PENDSVSET: PendSV set-pending bit.
	volatile uint32_t *pICSR = (uint32_t *)0xE000ED04;
	*pICSR |= (0x1<<28);  // set PENDSVSET call PendSV handler
}

/**********************************************************************/




void PendSV_Handler(void)
{
	gpiotoled2_update_screen();
}





//2. implement the fault handlers
void HardFault_Handler(void)
{
	printf("Exception : Hardfault\n");
	while(1);
}


void MemManage_Handler(void)
{
	printf("Exception : MemManage\n");
	while(1);
}

void BusFault_Handler(void)
{
	printf("Exception : BusFault\n");
	while(1);
}

void UsageFault_Handler(void)
{
	printf("Exception : UsageFault\n");
	while(1);
}
