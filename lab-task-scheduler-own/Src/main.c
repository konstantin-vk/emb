/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "itm_printf.h"
#include "sleep.h"
#include "main.h"

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif



/******************************************/
/*GLOBALS*/
/*User tasks storage*/
task_store_t 	tasks[MAXTASKS];
uint8_t 		task_running = 0;

uint32_t get_task_running_psp(void);
void     set_task_running_psp(uint32_t psp);

uint8_t  get_task_running(void);

uint8_t  get_next_task_running(void);
void     set_next_task_running(void);

/*Timer / SysTick*/
uint32_t tick=0;
void systick_initngo(void);

/*User tasks handlers*/
void t0_handler(void);
void t1_handler(void);
void t2_handler(void);
void t3_handler(void);
void idle_handler(void);


/*Init*/
void enable_processor_faults(void);
void tasks_stack_store_init(void);
__attribute__((naked)) void scheduler_stack_init (uint32_t stack_addr);

/*Do*/
__attribute__((naked))void switch_sp_to_psp(uint32_t stack_addr);


/******************************************/
int main(void)
{
	scheduler_stack_init(SCHEDULER_STACK_START);   	// set MSP value, move current stack add down
	//init_use_psp(SCHEDULER_STACK_START); 			// move main stack down

	tasks_stack_store_init();

	systick_initngo();

	// run user task
	switch_sp_to_psp(SCHEDULER_STACK_START); 			// switch to PSP: all user tasks should use PSP
	task_running=0;
	t0_handler();

	uint32_t x = 100;
	/* Loop forever */
	for(;;);
}

/******************************************/
/*User tasks storage*/
uint32_t get_task_running_psp(void){
	return tasks[task_running].PSP;
};
void set_task_running_psp(uint32_t psp){
	tasks[task_running].PSP = psp;
};
uint8_t get_task_running(void){
	return task_running;
};
uint8_t get_next_task_running(void){
	//if (task_running >= MAXTASKS-1) {return 0U;}
	//else {return task_running+1;};
	return ((++task_running)%MAXTASKS);
};
void set_next_task_running(void){
	task_running=get_next_task_running();
};

/******************************************/
/*Task handlers*/
void t0_handler(void){
	while (1){
		printf("task: 0\n");
		my_sleep(0.0001);
	}
};
void t1_handler(void){
	while (1){
		printf("task: 1\n");
		my_sleep(0.0001);
	}
};
void t2_handler(void){
	while (1){
		printf("task: 2\n");
		my_sleep(0.0001);
	}
};
void t3_handler(void){
	while (1){
		printf("task: 3\n");
		my_sleep(0.0001);
	}
};
void idle_handler(void){
	while (1){
		printf("task: idle\n");
		my_sleep(0.0001);
	}
};

/******************************************/
/*User tasks init*/
void tasks_stack_store_init(void){
	//PSP = stack addr
	tasks[0].PSP = (uint32_t *)(T0_STACK_START);
	tasks[1].PSP = (uint32_t *)(T1_STACK_START);
	tasks[2].PSP = (uint32_t *)(T2_STACK_START);
	tasks[3].PSP = (uint32_t *)(T3_STACK_START);
	//PC = handler
	tasks[0].taks_handler = ((uint32_t)t0_handler) ; 	// PC | T-Bit | 0x1
	tasks[1].taks_handler = ((uint32_t)t1_handler) ; 	// PC | T-Bit
	tasks[2].taks_handler = ((uint32_t)t2_handler) ; 	// PC | T-Bit
	tasks[3].taks_handler = ((uint32_t)t3_handler) ; 	// PC | T-Bit

	uint32_t *p_stack;
	//STACK FRAME (in stack)
	for (uint8_t i=0; i<MAXTASKS; ++i){

		p_stack = (uint32_t *)tasks[i].PSP;

		*(--p_stack) = ~(0xFFFFFFFF) | (0x1<<24);					// T-Bit (24) xPSR;
		*(--p_stack) = ((uint32_t)tasks[i].taks_handler ) | 0x1; ; 	// PC | T-Bit
		*(--p_stack) =   0xFFFFFFFD;   								// LR=EXC_RETURN=0xFFFFFFFD;
		for (uint8_t j = 0; j<=12; ++j ){
			*(--p_stack) = 0;				 				// Rn=~(0xFFFFFFFF)
		}
		tasks[i].PSP = (uint32_t)p_stack;
	};
};

__attribute__((naked)) void scheduler_stack_init (uint32_t stack_addr){
    __asm volatile("MSR MSP,%0": :  "r" (stack_addr)  :   ); // set stack address
    __asm volatile("BX LR"); // return - branch and exchange the instruction set
    //__asm volatile("BL");
};


/******************************************/
/*SysTick*/
void systick_initngo(void){
	*((uint32_t *)(SYST_RVR)) = SYST_SAFETY_BIT_MASK & SYST_RELOAD_VALUE; // 24bit register = clear upper bit
	/* TODO	1.2. Clear current value.*/
	*((uint32_t *)(SYST_CVR)) = 0x0U; //A write of any value clears the field to 0, and also clears the SYST_CSR COUNTFLAG bit to 0.
	/* TODO	1.3. Program Control and Status register.*/
	*((uint32_t *)(SYST_CSR)) |= (0x1U << 2); //CLKSOURCE = internal clock
	*((uint32_t *)(SYST_CSR)) |= (0x1U << 1); //TICKINT = asserts the SysTick exception request
	*((uint32_t *)(SYST_CSR)) |= (0x1U << 0); //ENABLE = counter enabled
}



/******************************************/
/*Init*/
void enable_processor_faults(void)
{
	uint32_t *pSHCSR = (uint32_t*)0xE000ED24;

	*pSHCSR |= ( 1 << 16); //mem manage
	*pSHCSR |= ( 1 << 17); //bus fault
	*pSHCSR |= ( 1 << 18); //usage fault
}


__attribute__((naked))void switch_sp_to_psp(uint32_t stack_addr){
	//__asm volatile ("PUSH {LR}"); //preserve LR which connects back to main()
	__asm volatile ("MSR PSP,%0"::"r"(stack_addr):);
	//__asm volatile ("POP {LR}");  //pops back LR value
	//change SP to PSP using CONTROL register
	__asm volatile ("MOV R0,#0X02");
	__asm volatile ("MSR CONTROL,R0");
	__asm volatile ("BX LR");
};


/***************************************************/
/*Handlers*/
__attribute__((naked))void SysTick_Handler(void){
	// save return address
	__asm volatile ("PUSH {LR}");
	// get current running task...done
	//save registers and psp
	__asm volatile("MRS R0,PSP");              // get process stack addr
	__asm volatile("STMDB R0!,{R4-R11}");      // save registers to process stack
	__asm volatile("BL set_task_running_psp"); // update saved psp with address changed during storage operation
	// get next task to run
	__asm volatile("BL set_next_task_running");  // mark next task active
	__asm volatile("BL get_task_running_psp");   // get saved psp (psp->R0)
	__asm volatile ("LDMIA R0!,{R4-R11}");       // load registers values from process stack
	__asm volatile("MSR PSP,R0");                // set stack address from saved psp
	//return
	__asm volatile ("POP {LR}");
	__asm volatile ("B SysTick_Handler_C"); // continue or return with __asm volatile ("BX LR");
}


void SysTick_Handler_C(void){
	tick++;
	printf("SysTick : %d\n", tick);
}



//2. implement the fault handlers
void HardFault_Handler(void)
{
	printf("Exception : Hardfault\n");
	while(1);
}


void MemManage_Handler(void)
{
	printf("Exception : MemManage\n");
	while(1);
}

void BusFault_Handler(void)
{
	printf("Exception : BusFault\n");
	while(1);
}

