/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

/*
 * TODO 1. setup timer for Scheduler
 * 		1.1. Program reload value.
 * 			F411 Data Sheet Table 39. HSI oscillator characteristics: fHSI = 16MHz = 16 000 000 Hz
 * 			1 ms = 1Khz = 1 000 Hz
 * 			reload_value = 16 000 000 / 1 000 = 16 000
 * TODO	1.1. Set Register SYST_RVR SysTick (Reload Value Register) value to 16 000
 * TODO	1.2. Clear current value.
 * TODO	1.3. Program Control and Status register.
 *
 * 2. Stack memory definition
 * 		1Kb per Tsk
 * 		start down from SRAM_END : SRAM_END-1KB....
 *
 * 3. Init Stacking Area for every Task process
 * 		Stack Frame 2 = holds all additional General Refister (R4-11), vaules = 0
 * 		Stack Frame 1 = all main General Registers (R0,1,2,3,12) values = 0
 * 		Stack Frame 1 = xPSR - set t-bit(24) , PC = set task handler address; LR=EXC_RETURN=0xFFFFFFFD
 *
 * 2. define 4 Thread processes
 * 3. implement stacking and unstacking
 * 4. round-robin Thread processes with SysTick interrupt
 * 5. round robin processes with SVCPend interrupt
 * */


/*
 * 1. Stack memory definition - 1k for each task
 * 0x2000 0000 - 0x2002 0000 SRAM1 (128 KB)
 * ??? tmp -  free upper mem for main stack ???
 * */
#define MAIN_STACK_SIZE      1024U  // tmp -  free upper mem for main stack ???
#define T_STACK_SIZE         1024U
#define SCHEDULER_STACK_SIZE 1024U

#define SRAM_START           0x20000000U
#define SRAM_SIZE            ((1024) * (128))
#define SRAM_END             ( (SRAM_START) + (SRAM_SIZE) )
							// = x0x20020000U



/*
 * Stack memory definition
 * REVERESE STACK ADDRESSING : START means higher address, END - lower
 * */
#define T0_STACK_START  		(( SRAM_END ) - ( 0*T_STACK_SIZE ))
#define T1_STACK_START  		(( SRAM_END ) - ( 1*T_STACK_SIZE ))
#define T2_STACK_START  		(( SRAM_END ) - ( 2*T_STACK_SIZE ))
#define T3_STACK_START  		(( SRAM_END ) - ( 3*T_STACK_SIZE ))
#define IDLE_STACK_START 		(( SRAM_END ) - ( 4*T_STACK_SIZE ))
#define SCHEDULER_STACK_START 	(( SRAM_END ) - ( 4*T_STACK_SIZE )- ( SCHEDULER_STACK_SIZE ))

// move stack down to prevent writes to Private stack area by main on app init
void scheduler_stack_init(uint32_t scheduler_stack_begin);

/*
 * 3. Init Stacking Area for every Task process
 * */
void Task_Init( uint32_t *pPrivateStack, void (*pTaskHandler)(void) , uint32_t * pPrivateTaskPSP);

/*
 * SysTick
 * */
#define SYST_SAFETY_BIT_MASK	0x00FFFFFFU			/* 24bit register = clear upper bit , ex: SYST_SAFETY_BIT_MASK & SYST_RELOAD_VALUE;*/
#define SYST_RELOAD_VALUE		16000U				/* Timer reload value = 1 ms/1KHz */
#define SYST_RVR				0xE000E014U			/* SYST_RVR SysTick (Reload Value Register) value to 16 000 */
#define SYST_CVR				0xE000E018U			/* SYST_CVR SysTick (Current Value Register) */
#define SYST_CSR				0xE000E010U			/* SYST_CSR (SysTick Control and Status Register)*/

uint32_t sysTickCounter=0;

void SysTick_Init(void);
void SysTick_Handler(void);

/*
 * Tasks
 * */
typedef struct {
	char name[10];
	uint32_t pPSP;
	void (*task_handler)(void);
} task_struct;

task_struct tasks[4];


void Task_Init( uint32_t *pPrivateStack, void (*pTaskHandler)(void) , uint32_t * pPrivateTaskPSP);
void task_init( task_struct task , char *name , uint32_t *p_stack, void (*task_handler)(void) );

void Task0_Handler(void);
void Task1_Handler(void);
void Task2_Handler(void);
void Task3_Handler(void);
void Idle_Handler(void);



int main(void)
{
	scheduler_stack_init(SCHEDULER_STACK_START);

	/*
	Task_Init((uint32_t *)(T0_STACK_START) , Task0_Handler , &tasks[0].pPSP);
	Task_Init((uint32_t *)(T1_STACK_START) , Task1_Handler , &tasks[1].pPSP);
	Task_Init((uint32_t *)(T2_STACK_START) , Task2_Handler , &tasks[2].pPSP);
	Task_Init((uint32_t *)(T3_STACK_START) , Task3_Handler , &tasks[3].pPSP);
	Task_Init((uint32_t *)(IDLE_STACK_START) , Idle_Handler, &tasks[4].pPSP);
	*/

	task_init( tasks[0], "Task0", (uint32_t *)(T0_STACK_START) , Task0_Handler);
	task_init( tasks[1], "Task1", (uint32_t *)(T1_STACK_START) , Task1_Handler);
	task_init( tasks[2], "Task2", (uint32_t *)(T2_STACK_START) , Task2_Handler);
	task_init( tasks[3], "Task3", (uint32_t *)(T3_STACK_START) , Task3_Handler);
	task_init( tasks[4], "Idle" , (uint32_t *)(IDLE_STACK_START) , Idle_Handler);


	SysTick_Init( );
    /* Loop forever */
	for(;;);
}


// move stack down to prevent writes to Private stack area by 'main' on app init
__attribute__((naked))void scheduler_stack_init(uint32_t scheduler_stack_begin){
	__asm volatile ("MSR MSP,%0"::"r"(scheduler_stack_begin):); //PSP | PSP  //r0
	__asm volatile ("BX LR");
}







void Task_Init( uint32_t *pPrivateStack, void (*pTaskHandler)(void) , uint32_t * pPrivateTaskPSP){
	// Stafck Frame 1
	*(--pPrivateStack) = ~(0xFFFFFFFF) | (0x1<<24);	// T-Bit (24) xPSR;
	*(--pPrivateStack) = ((uint32_t)pTaskHandler) | 0x1 ; 	//PC; T-Bit=  |0x1
	*(--pPrivateStack) =   0xFFFFFFFD;   	// LR=EXC_RETURN=0xFFFFFFFD;
	*(--pPrivateStack) = ~(0xFFFFFFFF);		// R0;
	*(--pPrivateStack) = ~(0xFFFFFFFF);		// R1;
	*(--pPrivateStack) = ~(0xFFFFFFFF);		// R2;
	*(--pPrivateStack) = ~(0xFFFFFFFF);		// R3;
	*(--pPrivateStack) = ~(0xFFFFFFFF);		// R12;
	// Stack frame 2
	*(--pPrivateStack) = ~(0xFFFFFFFF);		// R11;
	*(--pPrivateStack) = ~(0xFFFFFFFF);		// R10;
	*(--pPrivateStack) = ~(0xFFFFFFFF);		// R9;
	*(--pPrivateStack) = ~(0xFFFFFFFF);		// R8;
	*(--pPrivateStack) = ~(0xFFFFFFFF);		// R7;
	*(--pPrivateStack) = ~(0xFFFFFFFF);		// R6;
	*(--pPrivateStack) = ~(0xFFFFFFFF);		// R5;
	*(--pPrivateStack) = ~(0xFFFFFFFF);		// R4;
	*pPrivateTaskPSP = (uint32_t)pPrivateStack;
}


void task_init( task_struct task , char *name , uint32_t *p_stack, void (*task_handler)(void) ){
	//task.name = name;
	strcpy(task.name , name);
	task.task_handler = task_handler;
	*(--p_stack) = ~(0xFFFFFFFF) | (0x1<<24);			// T-Bit (24) xPSR;
	*(--p_stack) = ((uint32_t)task_handler) | 0x1  ; 	// PC | T-Bit
	*(--p_stack) =   0xFFFFFFFD;   					// LR=EXC_RETURN=0xFFFFFFFD;
	for (uint8_t i = 0; i<=12; ++i ){
		*(--p_stack) = 0;				 				// Rn=~(0xFFFFFFFF)
		printf("psp i=%d, (addr=%d)\n",i,p_stack);
	}
}



/*1. setup timer for Scheduler*/
void SysTick_Init(void){
	*((uint32_t *)(SYST_RVR)) = SYST_SAFETY_BIT_MASK & SYST_RELOAD_VALUE; // 24bit register = clear upper bit
	/* TODO	1.2. Clear current value.*/
	*((uint32_t *)(SYST_CVR)) = 0x0U; //A write of any value clears the field to 0, and also clears the SYST_CSR COUNTFLAG bit to 0.
	/* TODO	1.3. Program Control and Status register.*/
	*((uint32_t *)(SYST_CSR)) |= (0x1U << 2); //CLKSOURCE = internal clock
	*((uint32_t *)(SYST_CSR)) |= (0x1U << 1); //TICKINT = asserts the SysTick exception request
	*((uint32_t *)(SYST_CSR)) |= (0x1U << 0); //ENABLE = counter enabled
}

void SysTick_Handler(void){
	printf("SysTick handler:%li\n", sysTickCounter++);
}

void Task0_Handler(void){
	while(1){printf("task 0\n");};
}
void Task1_Handler(void){
	while(1){printf("task 1\n");};
}
void Task2_Handler(void){
	while(1){printf("task 2\n");};
}
void Task3_Handler(void){
	while(1){printf("task 3\n");};
}
void Idle_Handler(void){
	while(1){printf("idle 4\n");};
}
